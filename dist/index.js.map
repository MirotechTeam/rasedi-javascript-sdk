{"version":3,"sources":["../src/index.ts","../src/enums.ts","../src/client.ts","../src/auth.ts"],"sourcesContent":["export * from \"./enums\";\nexport * from \"./models\";\nexport * from \"./client\";\n// export * from './auth'; // Generally internal, but can export if needed\n","export enum Gateway {\n  FIB = \"FIB\",\n  ZAIN = \"ZAIN\",\n  ASIA_PAY = \"ASIA_PAY\",\n  FAST_PAY = \"FAST_PAY\",\n  NASS_WALLET = \"NASS_WALLET\",\n  CREDIT_CARD = \"CREDIT_CARD\",\n}\n\nexport enum PaymentStatus {\n  TIMED_OUT = \"TIMED_OUT\",\n  PENDING = \"PENDING\",\n  PAID = \"PAID\",\n  CANCELED = \"CANCELED\",\n  FAILED = \"FAILED\",\n}\n","import axios, { AxiosInstance, AxiosResponse } from \"axios\";\nimport { Auth } from \"./auth\";\nimport {\n  CreatePaymentPayload,\n  ApiResponse,\n  PaymentResponseBody,\n} from \"./models\";\nimport { PaymentStatus } from \"./enums\";\n\nexport class RasediClient {\n  private static readonly API_BASE_URL = \"https://stage.api.rasedi.com\";\n  private static readonly UPSTREAM_VERSION = 1;\n\n  private auth: Auth;\n  private httpClient: AxiosInstance;\n  private isTest: boolean;\n\n  constructor(\n    private privateKey: string,\n    private secretKey: string,\n  ) {\n    this.auth = new Auth(privateKey, secretKey);\n    this.isTest = secretKey.includes(\"test\");\n    this.httpClient = axios.create({\n      baseURL: RasediClient.API_BASE_URL,\n      timeout: 10000,\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      validateStatus: () => true, // Handle all statuses manually\n    });\n  }\n\n  private async call<T>(\n    path: string,\n    method: string,\n    body?: any,\n  ): Promise<ApiResponse<T>> {\n    const env = this.isTest ? \"test\" : \"live\";\n    const relativeUrl = `/v${RasediClient.UPSTREAM_VERSION}/payment/rest/${env}${path}`;\n\n    const signature = await this.auth.makeSignature(method, relativeUrl);\n\n    const headers = {\n      \"x-signature\": signature,\n      \"x-id\": this.auth.getKeyId(),\n    };\n\n    try {\n      const response: AxiosResponse = await this.httpClient.request({\n        url: relativeUrl,\n        method: method,\n        data: body,\n        headers: headers,\n      });\n\n      if (response.status < 200 || response.status > 209) {\n        throw new Error(\n          `Request failed with status ${response.status}: ${JSON.stringify(response.data)}`,\n        );\n      }\n\n      return {\n        body: response.data,\n        headers: response.headers as Record<string, string>,\n        statusCode: response.status,\n      };\n    } catch (error: any) {\n      throw error;\n    }\n  }\n\n  public async createPayment(\n    payload: CreatePaymentPayload,\n  ): Promise<ApiResponse<PaymentResponseBody>> {\n    return this.call<PaymentResponseBody>(\"/create\", \"POST\", payload);\n  }\n\n  public async getPaymentByReference(\n    referenceCode: string,\n  ): Promise<ApiResponse<PaymentResponseBody>> {\n    return this.call<PaymentResponseBody>(`/status/${referenceCode}`, \"GET\");\n  }\n\n  public async cancelPayment(\n    referenceCode: string,\n  ): Promise<ApiResponse<PaymentResponseBody>> {\n    return this.call<PaymentResponseBody>(`/cancel/${referenceCode}`, \"PATCH\");\n  }\n\n  // Placeholder for verification\n  public async verify(payload: any): Promise<any> {\n    throw new Error(\n      \"Verification not implemented for client-side SDK due to security risks of exposing public keys or logic.\",\n    );\n  }\n}\n","import forge from \"node-forge\";\nimport { ec as EC } from \"elliptic\";\nimport * as ed from \"@noble/ed25519\";\nimport { Buffer } from \"buffer\";\nimport { sha512 } from \"@noble/hashes/sha2.js\";\n\ned.etc.sha512Sync = (...m) => sha512(ed.etc.concatBytes(...m));\n\nexport class Auth {\n  constructor(\n    private privateKeyPem: string,\n    private keyId: string,\n  ) {}\n\n  public getKeyId(): string {\n    return this.keyId;\n  }\n\n  public async makeSignature(\n    method: string,\n    relativeUrl: string,\n  ): Promise<string> {\n    const rawSign = `${method} || ${this.keyId} || ${relativeUrl}`;\n    const data = Buffer.from(rawSign, \"utf8\");\n\n    // 1. Try RSA\n    try {\n      if (this.privateKeyPem.includes(\"RSA PRIVATE KEY\")) {\n        const privateKey = forge.pki.privateKeyFromPem(this.privateKeyPem);\n        const md = forge.md.sha256.create();\n        md.update(rawSign, \"utf8\");\n        const signature = privateKey.sign(md);\n        return forge.util.encode64(signature);\n      }\n    } catch (e) {\n      // Not RSA\n    }\n\n    // 2. Try EC (Secp256k1 / P-256)\n    // Basic heuristic: check if it parses as EC or headers\n    if (\n      this.privateKeyPem.includes(\"EC PRIVATE KEY\") ||\n      this.privateKeyPem.includes(\"BEGIN PRIVATE KEY\")\n    ) {\n      // We need to parse the PEM to get the key bytes/components.\n      // node-forge can parse generic Private Key info\n      try {\n        // If it's Ed25519, standard PEM parsers might fail or return specific OID\n        // Let's try manual check for Ed25519 first (generic PKCS8)\n        const cleanPem = this.privateKeyPem\n          .replace(/-----BEGIN PRIVATE KEY-----/g, \"\")\n          .replace(/-----END PRIVATE KEY-----/g, \"\")\n          .replace(/\\s+/g, \"\");\n\n        const bytes = Buffer.from(cleanPem, \"base64\");\n\n        // Ed25519 OID check (approximate)\n        if (\n          bytes.length > 16 &&\n          bytes[9] === 0x2b &&\n          bytes[10] === 0x65 &&\n          bytes[11] === 0x70\n        ) {\n          const seed = bytes.subarray(bytes.length - 32);\n          try {\n            // Ensure data is Uint8Array\n            const dataUint8 = new Uint8Array(data);\n            const signature = await ed.sign(dataUint8, seed);\n            return Buffer.from(signature).toString(\"base64\");\n          } catch (err) {\n            throw err;\n          }\n        }\n\n        // Otherwise assume generic EC (P-256/Secp256r1 typically for this API)\n        // Otherwise assume generic EC (P-256/Secp256r1 typically for this API)\n\n        // ... (rest of code)\n\n        const forgeKey = forge.pki.privateKeyFromPem(this.privateKeyPem) as any;\n        // Check curve\n        // For this SDK context, let's assume P-256 if it's EC and not Ed25519\n        const ec = new EC(\"p256\");\n        // Extract private key bytes from forge object\n        // forgeKey.privateKey is usually BigInteger\n        const keyHex = forgeKey.privateKey.toString(16);\n        const keyPair = ec.keyFromPrivate(keyHex);\n        const sig = keyPair.sign(data);\n\n        // Concatenate R and S (32 bytes each for P-256)\n        const r = sig.r.toArrayLike(Buffer, \"be\", 32);\n        const s = sig.s.toArrayLike(Buffer, \"be\", 32);\n        return Buffer.concat([r, s]).toString(\"base64\");\n      } catch (e) {\n        // Fallthrough\n      }\n    }\n\n    throw new Error(\"Unsupported Key Format or Signing Error\");\n  }\n}\n"],"mappings":"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","names":["index_exports","__export","Gateway","PaymentStatus","RasediClient","__toCommonJS","Gateway","PaymentStatus","import_axios","import_node_forge","import_elliptic","ed","import_buffer","import_sha2","m","Auth","privateKeyPem","keyId","method","relativeUrl","rawSign","data","privateKey","forge","md","signature","cleanPem","bytes","seed","dataUint8","err","forgeKey","ec","EC","keyHex","sig","r","s","_RasediClient","privateKey","secretKey","Auth","axios","path","method","body","env","relativeUrl","headers","response","error","payload","referenceCode","RasediClient"]}